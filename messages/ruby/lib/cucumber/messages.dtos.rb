require 'json'

# The code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
#

module Cucumber
  module Messages


    ##
    # Represents the Attachment message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # //// Attachments (parse errors, execution errors, screenshots, links...)
    # 
    # *
    #  An attachment represents any kind of data associated with a line in a
    #  [Source](#io.cucumber.messages.Source) file. It can be used for:
    # 
    #  * Syntax errors during parse time
    #  * Screenshots captured and attached during execution
    #  * Logs captured and attached during execution
    # 
    #  It is not to be used for runtime errors raised/thrown during execution. This
    #  is captured in `TestResult`.
    #

    class Attachment

      ##
      # *
      #  The body of the attachment. If `contentEncoding` is `IDENTITY`, the attachment
      #  is simply the string. If it's `BASE64`, the string should be Base64 decoded to
      #  obtain the attachment.

      attr_reader :body

      ##
      # *
      #  Whether to interpret `body` "as-is" (IDENTITY) or if it needs to be Base64-decoded (BASE64).
      # 
      #  Content encoding is *not* determined by the media type, but rather by the type
      #  of the object being attached:
      # 
      #  - string => IDENTITY
      #  - byte array => BASE64
      #  - stream => BASE64

      attr_reader :content_encoding

      ##
      # *
      #  Suggested file name of the attachment. (Provided by the user as an argument to `attach`)

      attr_reader :file_name

      ##
      # *
      #  The media type of the data. This can be any valid
      #  [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
      #  as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
      #  and `text/x.cucumber.stacktrace+plain`

      attr_reader :media_type

      attr_reader :source

      attr_reader :test_case_started_id

      attr_reader :test_step_id

      ##
      # *
      #  A URL where the attachment can be retrieved. This field should not be set by Cucumber.
      #  It should be set by a program that reads a message stream and does the following for
      #  each Attachment message:
      # 
      #  - Writes the body (after base64 decoding if necessary) to a new file.
      #  - Sets `body` and `contentEncoding` to `null`
      #  - Writes out the new attachment message
      # 
      #  This will result in a smaller message stream, which can improve performance and
      #  reduce bandwidth of message consumers. It also makes it easier to process and download attachments
      #  separately from reports.

      attr_reader :url

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          body: hash[:body],
          content_encoding: hash[:contentEncoding],
          file_name: hash[:fileName],
          media_type: hash[:mediaType],
          source: Source.from_camel_symbol_hash(hash[:source]),
          test_case_started_id: hash[:testCaseStartedId],
          test_step_id: hash[:testStepId],
          url: hash[:url],
        )
      end

      def initialize(
        body: '',
        content_encoding: AttachmentContentEncoding::IDENTITY,
        file_name: nil,
        media_type: '',
        source: nil,
        test_case_started_id: nil,
        test_step_id: nil,
        url: nil
      )
        @body = body
        @content_encoding = content_encoding
        @file_name = file_name
        @media_type = media_type
        @source = source
        @test_case_started_id = test_case_started_id
        @test_step_id = test_step_id
        @url = url
      end

      def to_camel_symbol_hash
        {
          body: body,
          contentEncoding: content_encoding,
          fileName: file_name,
          mediaType: media_type,
          source: source ? source.to_camel_symbol_hash : nil,
          testCaseStartedId: test_case_started_id,
          testStepId: test_step_id,
          url: url,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Duration message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # The structure is pretty close of the Timestamp one. For clarity, a second type
    #  of message is used.
    #

    class Duration

      attr_reader :seconds

      ##
      # Non-negative fractions of a second at nanosecond resolution. Negative
      #  second values with fractions must still have non-negative nanos values
      #  that count forward in time. Must be from 0 to 999,999,999
      #  inclusive.

      attr_reader :nanos

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          seconds: hash[:seconds],
          nanos: hash[:nanos],
        )
      end

      def initialize(
        seconds: 0,
        nanos: 0
      )
        @seconds = seconds
        @nanos = nanos
      end

      def to_camel_symbol_hash
        {
          seconds: seconds,
          nanos: nanos,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Envelope message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # When removing a field, replace it with reserved, rather than deleting the line.
    #  When adding a field, add it to the end and increment the number by one.
    #  See https://developers.google.com/protocol-buffers/docs/proto#updating for details
    # 
    # *
    #  All the messages that are passed between different components/processes are Envelope
    #  messages.
    #

    class Envelope

      attr_reader :attachment

      attr_reader :gherkin_document

      attr_reader :hook

      attr_reader :meta

      attr_reader :parameter_type

      attr_reader :parse_error

      attr_reader :pickle

      attr_reader :source

      attr_reader :step_definition

      attr_reader :test_case

      attr_reader :test_case_finished

      attr_reader :test_case_started

      attr_reader :test_run_finished

      attr_reader :test_run_started

      attr_reader :test_step_finished

      attr_reader :test_step_started

      attr_reader :undefined_parameter_type

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          attachment: Attachment.from_camel_symbol_hash(hash[:attachment]),
          gherkin_document: GherkinDocument.from_camel_symbol_hash(hash[:gherkinDocument]),
          hook: Hook.from_camel_symbol_hash(hash[:hook]),
          meta: Meta.from_camel_symbol_hash(hash[:meta]),
          parameter_type: ParameterType.from_camel_symbol_hash(hash[:parameterType]),
          parse_error: ParseError.from_camel_symbol_hash(hash[:parseError]),
          pickle: Pickle.from_camel_symbol_hash(hash[:pickle]),
          source: Source.from_camel_symbol_hash(hash[:source]),
          step_definition: StepDefinition.from_camel_symbol_hash(hash[:stepDefinition]),
          test_case: TestCase.from_camel_symbol_hash(hash[:testCase]),
          test_case_finished: TestCaseFinished.from_camel_symbol_hash(hash[:testCaseFinished]),
          test_case_started: TestCaseStarted.from_camel_symbol_hash(hash[:testCaseStarted]),
          test_run_finished: TestRunFinished.from_camel_symbol_hash(hash[:testRunFinished]),
          test_run_started: TestRunStarted.from_camel_symbol_hash(hash[:testRunStarted]),
          test_step_finished: TestStepFinished.from_camel_symbol_hash(hash[:testStepFinished]),
          test_step_started: TestStepStarted.from_camel_symbol_hash(hash[:testStepStarted]),
          undefined_parameter_type: UndefinedParameterType.from_camel_symbol_hash(hash[:undefinedParameterType]),
        )
      end

      def initialize(
        attachment: nil,
        gherkin_document: nil,
        hook: nil,
        meta: nil,
        parameter_type: nil,
        parse_error: nil,
        pickle: nil,
        source: nil,
        step_definition: nil,
        test_case: nil,
        test_case_finished: nil,
        test_case_started: nil,
        test_run_finished: nil,
        test_run_started: nil,
        test_step_finished: nil,
        test_step_started: nil,
        undefined_parameter_type: nil
      )
        @attachment = attachment
        @gherkin_document = gherkin_document
        @hook = hook
        @meta = meta
        @parameter_type = parameter_type
        @parse_error = parse_error
        @pickle = pickle
        @source = source
        @step_definition = step_definition
        @test_case = test_case
        @test_case_finished = test_case_finished
        @test_case_started = test_case_started
        @test_run_finished = test_run_finished
        @test_run_started = test_run_started
        @test_step_finished = test_step_finished
        @test_step_started = test_step_started
        @undefined_parameter_type = undefined_parameter_type
      end

      def to_camel_symbol_hash
        {
          attachment: attachment ? attachment.to_camel_symbol_hash : nil,
          gherkinDocument: gherkin_document ? gherkin_document.to_camel_symbol_hash : nil,
          hook: hook ? hook.to_camel_symbol_hash : nil,
          meta: meta ? meta.to_camel_symbol_hash : nil,
          parameterType: parameter_type ? parameter_type.to_camel_symbol_hash : nil,
          parseError: parse_error ? parse_error.to_camel_symbol_hash : nil,
          pickle: pickle ? pickle.to_camel_symbol_hash : nil,
          source: source ? source.to_camel_symbol_hash : nil,
          stepDefinition: step_definition ? step_definition.to_camel_symbol_hash : nil,
          testCase: test_case ? test_case.to_camel_symbol_hash : nil,
          testCaseFinished: test_case_finished ? test_case_finished.to_camel_symbol_hash : nil,
          testCaseStarted: test_case_started ? test_case_started.to_camel_symbol_hash : nil,
          testRunFinished: test_run_finished ? test_run_finished.to_camel_symbol_hash : nil,
          testRunStarted: test_run_started ? test_run_started.to_camel_symbol_hash : nil,
          testStepFinished: test_step_finished ? test_step_finished.to_camel_symbol_hash : nil,
          testStepStarted: test_step_started ? test_step_started.to_camel_symbol_hash : nil,
          undefinedParameterType: undefined_parameter_type ? undefined_parameter_type.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the GherkinDocument message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
    #  Cucumber implementations should *not* depend on `GherkinDocument` or any of its
    #  children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
    # 
    #  The only consumers of `GherkinDocument` should only be formatters that produce
    #  "rich" output, resembling the original Gherkin document.
    #

    class GherkinDocument

      ##
      # *
      #  The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
      #  of the source, typically a file path relative to the root directory

      attr_reader :uri

      attr_reader :feature

      ##
      # All the comments in the Gherkin document

      attr_reader :comments

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          uri: hash[:uri],
          feature: Feature.from_camel_symbol_hash(hash[:feature]),
          comments: hash[:comments],
        )
      end

      def initialize(
        uri: nil,
        feature: nil,
        comments: []
      )
        @uri = uri
        @feature = feature
        @comments = comments
      end

      def to_camel_symbol_hash
        {
          uri: uri,
          feature: feature ? feature.to_camel_symbol_hash : nil,
          comments: comments,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Background message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Background

      ##
      # The location of the `Background` keyword

      attr_reader :location

      attr_reader :keyword

      attr_reader :name

      attr_reader :description

      attr_reader :steps

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          steps: hash[:steps],
          id: hash[:id],
        )
      end

      def initialize(
        location: Location.new,
        keyword: '',
        name: '',
        description: '',
        steps: [],
        id: ''
      )
        @location = location
        @keyword = keyword
        @name = name
        @description = description
        @steps = steps
        @id = id
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          keyword: keyword,
          name: name,
          description: description,
          steps: steps,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Comment message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  A comment in a Gherkin document
    #

    class Comment

      ##
      # The location of the comment

      attr_reader :location

      ##
      # The text of the comment

      attr_reader :text

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          text: hash[:text],
        )
      end

      def initialize(
        location: Location.new,
        text: ''
      )
        @location = location
        @text = text
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          text: text,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the DataTable message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class DataTable

      attr_reader :location

      attr_reader :rows

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          rows: hash[:rows],
        )
      end

      def initialize(
        location: Location.new,
        rows: []
      )
        @location = location
        @rows = rows
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          rows: rows,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the DocString message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class DocString

      attr_reader :location

      attr_reader :media_type

      attr_reader :content

      attr_reader :delimiter

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          media_type: hash[:mediaType],
          content: hash[:content],
          delimiter: hash[:delimiter],
        )
      end

      def initialize(
        location: Location.new,
        media_type: nil,
        content: '',
        delimiter: ''
      )
        @location = location
        @media_type = media_type
        @content = content
        @delimiter = delimiter
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          mediaType: media_type,
          content: content,
          delimiter: delimiter,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Examples message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Examples

      ##
      # The location of the `Examples` keyword

      attr_reader :location

      attr_reader :tags

      attr_reader :keyword

      attr_reader :name

      attr_reader :description

      attr_reader :table_header

      attr_reader :table_body

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          tags: hash[:tags],
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          table_header: TableRow.from_camel_symbol_hash(hash[:tableHeader]),
          table_body: hash[:tableBody],
          id: hash[:id],
        )
      end

      def initialize(
        location: Location.new,
        tags: [],
        keyword: '',
        name: '',
        description: '',
        table_header: nil,
        table_body: [],
        id: ''
      )
        @location = location
        @tags = tags
        @keyword = keyword
        @name = name
        @description = description
        @table_header = table_header
        @table_body = table_body
        @id = id
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          tags: tags,
          keyword: keyword,
          name: name,
          description: description,
          tableHeader: table_header ? table_header.to_camel_symbol_hash : nil,
          tableBody: table_body,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Feature message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Feature

      ##
      # The location of the `Feature` keyword

      attr_reader :location

      ##
      # All the tags placed above the `Feature` keyword

      attr_reader :tags

      ##
      # The [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code of the Gherkin document

      attr_reader :language

      ##
      # The text of the `Feature` keyword (in the language specified by `language`)

      attr_reader :keyword

      ##
      # The name of the feature (the text following the `keyword`)

      attr_reader :name

      ##
      # The line(s) underneath the line with the `keyword` that are used as description

      attr_reader :description

      ##
      # Zero or more children

      attr_reader :children

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          tags: hash[:tags],
          language: hash[:language],
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          children: hash[:children],
        )
      end

      def initialize(
        location: Location.new,
        tags: [],
        language: '',
        keyword: '',
        name: '',
        description: '',
        children: []
      )
        @location = location
        @tags = tags
        @language = language
        @keyword = keyword
        @name = name
        @description = description
        @children = children
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          tags: tags,
          language: language,
          keyword: keyword,
          name: name,
          description: description,
          children: children,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the FeatureChild message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  A child node of a `Feature` node
    #

    class FeatureChild

      attr_reader :rule

      attr_reader :background

      attr_reader :scenario

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          rule: Rule.from_camel_symbol_hash(hash[:rule]),
          background: Background.from_camel_symbol_hash(hash[:background]),
          scenario: Scenario.from_camel_symbol_hash(hash[:scenario]),
        )
      end

      def initialize(
        rule: nil,
        background: nil,
        scenario: nil
      )
        @rule = rule
        @background = background
        @scenario = scenario
      end

      def to_camel_symbol_hash
        {
          rule: rule ? rule.to_camel_symbol_hash : nil,
          background: background ? background.to_camel_symbol_hash : nil,
          scenario: scenario ? scenario.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Rule message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Rule

      ##
      # The location of the `Rule` keyword

      attr_reader :location

      ##
      # All the tags placed above the `Rule` keyword

      attr_reader :tags

      attr_reader :keyword

      attr_reader :name

      attr_reader :description

      attr_reader :children

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          tags: hash[:tags],
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          children: hash[:children],
          id: hash[:id],
        )
      end

      def initialize(
        location: Location.new,
        tags: [],
        keyword: '',
        name: '',
        description: '',
        children: [],
        id: ''
      )
        @location = location
        @tags = tags
        @keyword = keyword
        @name = name
        @description = description
        @children = children
        @id = id
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          tags: tags,
          keyword: keyword,
          name: name,
          description: description,
          children: children,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the RuleChild message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  A child node of a `Rule` node
    #

    class RuleChild

      attr_reader :background

      attr_reader :scenario

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          background: Background.from_camel_symbol_hash(hash[:background]),
          scenario: Scenario.from_camel_symbol_hash(hash[:scenario]),
        )
      end

      def initialize(
        background: nil,
        scenario: nil
      )
        @background = background
        @scenario = scenario
      end

      def to_camel_symbol_hash
        {
          background: background ? background.to_camel_symbol_hash : nil,
          scenario: scenario ? scenario.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Scenario message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Scenario

      ##
      # The location of the `Scenario` keyword

      attr_reader :location

      attr_reader :tags

      attr_reader :keyword

      attr_reader :name

      attr_reader :description

      attr_reader :steps

      attr_reader :examples

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          tags: hash[:tags],
          keyword: hash[:keyword],
          name: hash[:name],
          description: hash[:description],
          steps: hash[:steps],
          examples: hash[:examples],
          id: hash[:id],
        )
      end

      def initialize(
        location: Location.new,
        tags: [],
        keyword: '',
        name: '',
        description: '',
        steps: [],
        examples: [],
        id: ''
      )
        @location = location
        @tags = tags
        @keyword = keyword
        @name = name
        @description = description
        @steps = steps
        @examples = examples
        @id = id
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          tags: tags,
          keyword: keyword,
          name: name,
          description: description,
          steps: steps,
          examples: examples,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Step message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # A step
    #

    class Step

      ##
      # The location of the steps' `keyword`

      attr_reader :location

      attr_reader :keyword

      attr_reader :text

      attr_reader :doc_string

      attr_reader :data_table

      ##
      # Unique ID to be able to reference the Step from PickleStep

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          keyword: hash[:keyword],
          text: hash[:text],
          doc_string: DocString.from_camel_symbol_hash(hash[:docString]),
          data_table: DataTable.from_camel_symbol_hash(hash[:dataTable]),
          id: hash[:id],
        )
      end

      def initialize(
        location: Location.new,
        keyword: '',
        text: '',
        doc_string: nil,
        data_table: nil,
        id: ''
      )
        @location = location
        @keyword = keyword
        @text = text
        @doc_string = doc_string
        @data_table = data_table
        @id = id
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          keyword: keyword,
          text: text,
          docString: doc_string ? doc_string.to_camel_symbol_hash : nil,
          dataTable: data_table ? data_table.to_camel_symbol_hash : nil,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TableCell message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # A cell in a `TableRow`
    #

    class TableCell

      ##
      # The location of the cell

      attr_reader :location

      ##
      # The value of the cell

      attr_reader :value

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          value: hash[:value],
        )
      end

      def initialize(
        location: Location.new,
        value: ''
      )
        @location = location
        @value = value
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          value: value,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TableRow message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # A row in a table
    #

    class TableRow

      ##
      # The location of the first cell in the row

      attr_reader :location

      ##
      # Cells in the row

      attr_reader :cells

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          cells: hash[:cells],
          id: hash[:id],
        )
      end

      def initialize(
        location: Location.new,
        cells: [],
        id: ''
      )
        @location = location
        @cells = cells
        @id = id
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          cells: cells,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Tag message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  A tag
    #

    class Tag

      ##
      # Location of the tag

      attr_reader :location

      ##
      # The name of the tag (including the leading `@`)

      attr_reader :name

      ##
      # Unique ID to be able to reference the Tag from PickleTag

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          location: Location.from_camel_symbol_hash(hash[:location]),
          name: hash[:name],
          id: hash[:id],
        )
      end

      def initialize(
        location: Location.new,
        name: '',
        id: ''
      )
        @location = location
        @name = name
        @id = id
      end

      def to_camel_symbol_hash
        {
          location: location ? location.to_camel_symbol_hash : nil,
          name: name,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Hook message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Hook

      attr_reader :id

      attr_reader :source_reference

      attr_reader :tag_expression

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          id: hash[:id],
          source_reference: SourceReference.from_camel_symbol_hash(hash[:sourceReference]),
          tag_expression: hash[:tagExpression],
        )
      end

      def initialize(
        id: '',
        source_reference: SourceReference.new,
        tag_expression: nil
      )
        @id = id
        @source_reference = source_reference
        @tag_expression = tag_expression
      end

      def to_camel_symbol_hash
        {
          id: id,
          sourceReference: source_reference ? source_reference.to_camel_symbol_hash : nil,
          tagExpression: tag_expression,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Location message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  Points to a line and a column in a text file
    #

    class Location

      attr_reader :line

      attr_reader :column

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          line: hash[:line],
          column: hash[:column],
        )
      end

      def initialize(
        line: 0,
        column: nil
      )
        @line = line
        @column = column
      end

      def to_camel_symbol_hash
        {
          line: line,
          column: column,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Meta message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  This message contains meta information about the environment. Consumers can use
    #  this for various purposes.
    #

    class Meta

      ##
      # *
      #  The [SEMVER](https://semver.org/) version number of the protocol

      attr_reader :protocol_version

      ##
      # SpecFlow, Cucumber-JVM, Cucumber.js, Cucumber-Ruby, Behat etc.

      attr_reader :implementation

      ##
      # Java, Ruby, Node.js etc

      attr_reader :runtime

      ##
      # Windows, Linux, MacOS etc

      attr_reader :os

      ##
      # 386, arm, amd64 etc

      attr_reader :cpu

      attr_reader :ci

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          protocol_version: hash[:protocolVersion],
          implementation: Product.from_camel_symbol_hash(hash[:implementation]),
          runtime: Product.from_camel_symbol_hash(hash[:runtime]),
          os: Product.from_camel_symbol_hash(hash[:os]),
          cpu: Product.from_camel_symbol_hash(hash[:cpu]),
          ci: Ci.from_camel_symbol_hash(hash[:ci]),
        )
      end

      def initialize(
        protocol_version: '',
        implementation: Product.new,
        runtime: Product.new,
        os: Product.new,
        cpu: Product.new,
        ci: nil
      )
        @protocol_version = protocol_version
        @implementation = implementation
        @runtime = runtime
        @os = os
        @cpu = cpu
        @ci = ci
      end

      def to_camel_symbol_hash
        {
          protocolVersion: protocol_version,
          implementation: implementation ? implementation.to_camel_symbol_hash : nil,
          runtime: runtime ? runtime.to_camel_symbol_hash : nil,
          os: os ? os.to_camel_symbol_hash : nil,
          cpu: cpu ? cpu.to_camel_symbol_hash : nil,
          ci: ci ? ci.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Ci message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # CI environment
    #

    class Ci

      ##
      # Name of the CI product, e.g. "Jenkins", "CircleCI" etc.

      attr_reader :name

      ##
      # Link to the build

      attr_reader :url

      attr_reader :git

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          name: hash[:name],
          url: hash[:url],
          git: Git.from_camel_symbol_hash(hash[:git]),
        )
      end

      def initialize(
        name: '',
        url: nil,
        git: nil
      )
        @name = name
        @url = url
        @git = git
      end

      def to_camel_symbol_hash
        {
          name: name,
          url: url,
          git: git ? git.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Git message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # Information about Git, provided by the Build/CI server as environment
    #  variables.
    #

    class Git

      attr_reader :remote

      attr_reader :revision

      attr_reader :branch

      attr_reader :tag

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          remote: hash[:remote],
          revision: hash[:revision],
          branch: hash[:branch],
          tag: hash[:tag],
        )
      end

      def initialize(
        remote: '',
        revision: '',
        branch: nil,
        tag: nil
      )
        @remote = remote
        @revision = revision
        @branch = branch
        @tag = tag
      end

      def to_camel_symbol_hash
        {
          remote: remote,
          revision: revision,
          branch: branch,
          tag: tag,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Product message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # Used to describe various properties of Meta
    #

    class Product

      ##
      # The product name

      attr_reader :name

      ##
      # The product version

      attr_reader :version

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          name: hash[:name],
          version: hash[:version],
        )
      end

      def initialize(
        name: '',
        version: nil
      )
        @name = name
        @version = version
      end

      def to_camel_symbol_hash
        {
          name: name,
          version: version,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the ParameterType message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class ParameterType

      ##
      # The name is unique, so we don't need an id.

      attr_reader :name

      attr_reader :regular_expressions

      attr_reader :prefer_for_regular_expression_match

      attr_reader :use_for_snippets

      attr_reader :id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          name: hash[:name],
          regular_expressions: hash[:regularExpressions],
          prefer_for_regular_expression_match: hash[:preferForRegularExpressionMatch],
          use_for_snippets: hash[:useForSnippets],
          id: hash[:id],
        )
      end

      def initialize(
        name: '',
        regular_expressions: [],
        prefer_for_regular_expression_match: false,
        use_for_snippets: false,
        id: ''
      )
        @name = name
        @regular_expressions = regular_expressions
        @prefer_for_regular_expression_match = prefer_for_regular_expression_match
        @use_for_snippets = use_for_snippets
        @id = id
      end

      def to_camel_symbol_hash
        {
          name: name,
          regularExpressions: regular_expressions,
          preferForRegularExpressionMatch: prefer_for_regular_expression_match,
          useForSnippets: use_for_snippets,
          id: id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the ParseError message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class ParseError

      attr_reader :source

      attr_reader :message

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          source: SourceReference.from_camel_symbol_hash(hash[:source]),
          message: hash[:message],
        )
      end

      def initialize(
        source: SourceReference.new,
        message: ''
      )
        @source = source
        @message = message
      end

      def to_camel_symbol_hash
        {
          source: source ? source.to_camel_symbol_hash : nil,
          message: message,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Pickle message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # //// Pickles
    # 
    # *
    #  A `Pickle` represents a template for a `TestCase`. It is typically derived
    #  from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
    #  In the future a `Pickle` may be derived from other formats such as Markdown or
    #  Excel files.
    # 
    #  By making `Pickle` the main data structure Cucumber uses for execution, the
    #  implementation of Cucumber itself becomes simpler, as it doesn't have to deal
    #  with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
    # 
    #  Each `PickleStep` of a `Pickle` is matched with a `StepDefinition` to create a `TestCase`
    #

    class Pickle

      ##
      # *
      #  A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
      #  from the source data and the `locations` of the pickle.
      #  This ID will change if source the file is modified.

      attr_reader :id

      ##
      # The uri of the source file

      attr_reader :uri

      ##
      # The name of the pickle

      attr_reader :name

      ##
      # The language of the pickle

      attr_reader :language

      ##
      # One or more steps

      attr_reader :steps

      ##
      # *
      #  One or more tags. If this pickle is constructed from a Gherkin document,
      #  It includes inherited tags from the `Feature` as well.

      attr_reader :tags

      ##
      # *
      #  Points to the AST node locations of the pickle. The last one represents the unique
      #  id of the pickle. A pickle constructed from `Examples` will have the first
      #  id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.

      attr_reader :ast_node_ids

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          id: hash[:id],
          uri: hash[:uri],
          name: hash[:name],
          language: hash[:language],
          steps: hash[:steps],
          tags: hash[:tags],
          ast_node_ids: hash[:astNodeIds],
        )
      end

      def initialize(
        id: '',
        uri: '',
        name: '',
        language: '',
        steps: [],
        tags: [],
        ast_node_ids: []
      )
        @id = id
        @uri = uri
        @name = name
        @language = language
        @steps = steps
        @tags = tags
        @ast_node_ids = ast_node_ids
      end

      def to_camel_symbol_hash
        {
          id: id,
          uri: uri,
          name: name,
          language: language,
          steps: steps,
          tags: tags,
          astNodeIds: ast_node_ids,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the PickleDocString message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class PickleDocString

      attr_reader :media_type

      attr_reader :content

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          media_type: hash[:mediaType],
          content: hash[:content],
        )
      end

      def initialize(
        media_type: nil,
        content: ''
      )
        @media_type = media_type
        @content = content
      end

      def to_camel_symbol_hash
        {
          mediaType: media_type,
          content: content,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the PickleStep message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  An executable step
    #

    class PickleStep

      attr_reader :argument

      ##
      # References the IDs of the source of the step. For Gherkin, this can be
      #  the ID of a Step, and possibly also the ID of a TableRow

      attr_reader :ast_node_ids

      ##
      # A unique ID for the PickleStep

      attr_reader :id

      attr_reader :text

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          argument: PickleStepArgument.from_camel_symbol_hash(hash[:argument]),
          ast_node_ids: hash[:astNodeIds],
          id: hash[:id],
          text: hash[:text],
        )
      end

      def initialize(
        argument: nil,
        ast_node_ids: [],
        id: '',
        text: ''
      )
        @argument = argument
        @ast_node_ids = ast_node_ids
        @id = id
        @text = text
      end

      def to_camel_symbol_hash
        {
          argument: argument ? argument.to_camel_symbol_hash : nil,
          astNodeIds: ast_node_ids,
          id: id,
          text: text,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the PickleStepArgument message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # An optional argument
    #

    class PickleStepArgument

      attr_reader :doc_string

      attr_reader :data_table

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          doc_string: PickleDocString.from_camel_symbol_hash(hash[:docString]),
          data_table: PickleTable.from_camel_symbol_hash(hash[:dataTable]),
        )
      end

      def initialize(
        doc_string: nil,
        data_table: nil
      )
        @doc_string = doc_string
        @data_table = data_table
      end

      def to_camel_symbol_hash
        {
          docString: doc_string ? doc_string.to_camel_symbol_hash : nil,
          dataTable: data_table ? data_table.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the PickleTable message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class PickleTable

      attr_reader :rows

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          rows: hash[:rows],
        )
      end

      def initialize(
        rows: []
      )
        @rows = rows
      end

      def to_camel_symbol_hash
        {
          rows: rows,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the PickleTableCell message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class PickleTableCell

      attr_reader :value

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          value: hash[:value],
        )
      end

      def initialize(
        value: ''
      )
        @value = value
      end

      def to_camel_symbol_hash
        {
          value: value,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the PickleTableRow message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class PickleTableRow

      attr_reader :cells

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          cells: hash[:cells],
        )
      end

      def initialize(
        cells: []
      )
        @cells = cells
      end

      def to_camel_symbol_hash
        {
          cells: cells,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the PickleTag message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  A tag
    #

    class PickleTag

      attr_reader :name

      ##
      # Points to the AST node this was created from

      attr_reader :ast_node_id

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          name: hash[:name],
          ast_node_id: hash[:astNodeId],
        )
      end

      def initialize(
        name: '',
        ast_node_id: ''
      )
        @name = name
        @ast_node_id = ast_node_id
      end

      def to_camel_symbol_hash
        {
          name: name,
          astNodeId: ast_node_id,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Source message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # //// Source
    # 
    # *
    #  A source file, typically a Gherkin document or Java/Ruby/JavaScript source code
    #

    class Source

      ##
      # *
      #  The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
      #  of the source, typically a file path relative to the root directory

      attr_reader :uri

      ##
      # The contents of the file

      attr_reader :data

      ##
      # The media type of the file. Can be used to specify custom types, such as
      #  text/x.cucumber.gherkin+plain

      attr_reader :media_type

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          uri: hash[:uri],
          data: hash[:data],
          media_type: hash[:mediaType],
        )
      end

      def initialize(
        uri: '',
        data: '',
        media_type: SourceMediaType::TEXT_X_CUCUMBER_GHERKIN_PLAIN
      )
        @uri = uri
        @data = data
        @media_type = media_type
      end

      def to_camel_symbol_hash
        {
          uri: uri,
          data: data,
          mediaType: media_type,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the SourceReference message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
    #  [Location](#io.cucumber.messages.Location) within that file.
    #

    class SourceReference

      attr_reader :uri

      attr_reader :java_method

      attr_reader :java_stack_trace_element

      attr_reader :location

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          uri: hash[:uri],
          java_method: JavaMethod.from_camel_symbol_hash(hash[:javaMethod]),
          java_stack_trace_element: JavaStackTraceElement.from_camel_symbol_hash(hash[:javaStackTraceElement]),
          location: Location.from_camel_symbol_hash(hash[:location]),
        )
      end

      def initialize(
        uri: nil,
        java_method: nil,
        java_stack_trace_element: nil,
        location: nil
      )
        @uri = uri
        @java_method = java_method
        @java_stack_trace_element = java_stack_trace_element
        @location = location
      end

      def to_camel_symbol_hash
        {
          uri: uri,
          javaMethod: java_method ? java_method.to_camel_symbol_hash : nil,
          javaStackTraceElement: java_stack_trace_element ? java_stack_trace_element.to_camel_symbol_hash : nil,
          location: location ? location.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the JavaMethod message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class JavaMethod

      attr_reader :class_name

      attr_reader :method_name

      attr_reader :method_parameter_types

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          class_name: hash[:className],
          method_name: hash[:methodName],
          method_parameter_types: hash[:methodParameterTypes],
        )
      end

      def initialize(
        class_name: '',
        method_name: '',
        method_parameter_types: []
      )
        @class_name = class_name
        @method_name = method_name
        @method_parameter_types = method_parameter_types
      end

      def to_camel_symbol_hash
        {
          className: class_name,
          methodName: method_name,
          methodParameterTypes: method_parameter_types,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the JavaStackTraceElement message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class JavaStackTraceElement

      attr_reader :class_name

      attr_reader :file_name

      attr_reader :method_name

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          class_name: hash[:className],
          file_name: hash[:fileName],
          method_name: hash[:methodName],
        )
      end

      def initialize(
        class_name: '',
        file_name: '',
        method_name: ''
      )
        @class_name = class_name
        @file_name = file_name
        @method_name = method_name
      end

      def to_camel_symbol_hash
        {
          className: class_name,
          fileName: file_name,
          methodName: method_name,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the StepDefinition message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class StepDefinition

      attr_reader :id

      attr_reader :pattern

      attr_reader :source_reference

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          id: hash[:id],
          pattern: StepDefinitionPattern.from_camel_symbol_hash(hash[:pattern]),
          source_reference: SourceReference.from_camel_symbol_hash(hash[:sourceReference]),
        )
      end

      def initialize(
        id: '',
        pattern: StepDefinitionPattern.new,
        source_reference: SourceReference.new
      )
        @id = id
        @pattern = pattern
        @source_reference = source_reference
      end

      def to_camel_symbol_hash
        {
          id: id,
          pattern: pattern ? pattern.to_camel_symbol_hash : nil,
          sourceReference: source_reference ? source_reference.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the StepDefinitionPattern message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class StepDefinitionPattern

      attr_reader :source

      attr_reader :type

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          source: hash[:source],
          type: hash[:type],
        )
      end

      def initialize(
        source: '',
        type: StepDefinitionPatternType::CUCUMBER_EXPRESSION
      )
        @source = source
        @type = type
      end

      def to_camel_symbol_hash
        {
          source: source,
          type: type,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestCase message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # //// TestCases
    # 
    # *
    #  A `TestCase` contains a sequence of `TestStep`s.
    #

    class TestCase

      attr_reader :id

      ##
      # The ID of the `Pickle` this `TestCase` is derived from.

      attr_reader :pickle_id

      attr_reader :test_steps

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          id: hash[:id],
          pickle_id: hash[:pickleId],
          test_steps: hash[:testSteps],
        )
      end

      def initialize(
        id: '',
        pickle_id: '',
        test_steps: []
      )
        @id = id
        @pickle_id = pickle_id
        @test_steps = test_steps
      end

      def to_camel_symbol_hash
        {
          id: id,
          pickleId: pickle_id,
          testSteps: test_steps,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Group message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Group

      attr_reader :children

      attr_reader :start

      attr_reader :value

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          children: hash[:children],
          start: hash[:start],
          value: hash[:value],
        )
      end

      def initialize(
        children: [],
        start: nil,
        value: nil
      )
        @children = children
        @start = start
        @value = value
      end

      def to_camel_symbol_hash
        {
          children: children,
          start: start,
          value: value,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the StepMatchArgument message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  Represents a single argument extracted from a step match and passed to a step definition.
    #  This is used for the following purposes:
    #  - Construct an argument to pass to a step definition (possibly through a parameter type transform)
    #  - Highlight the matched parameter in rich formatters such as the HTML formatter
    # 
    #  This message closely matches the `Argument` class in the `cucumber-expressions` library.
    #

    class StepMatchArgument

      ##
      # *
      #  Represents the outermost capture group of an argument. This message closely matches the
      #  `Group` class in the `cucumber-expressions` library.

      attr_reader :group

      attr_reader :parameter_type_name

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          group: Group.from_camel_symbol_hash(hash[:group]),
          parameter_type_name: hash[:parameterTypeName],
        )
      end

      def initialize(
        group: Group.new,
        parameter_type_name: nil
      )
        @group = group
        @parameter_type_name = parameter_type_name
      end

      def to_camel_symbol_hash
        {
          group: group ? group.to_camel_symbol_hash : nil,
          parameterTypeName: parameter_type_name,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the StepMatchArgumentsList message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class StepMatchArgumentsList

      attr_reader :step_match_arguments

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          step_match_arguments: hash[:stepMatchArguments],
        )
      end

      def initialize(
        step_match_arguments: []
      )
        @step_match_arguments = step_match_arguments
      end

      def to_camel_symbol_hash
        {
          stepMatchArguments: step_match_arguments,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestStep message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    # *
    #  A `TestStep` is derived from either a `PickleStep`
    #  combined with a `StepDefinition`, or from a `Hook`.
    #

    class TestStep

      ##
      # Pointer to the `Hook` (if derived from a Hook)

      attr_reader :hook_id

      attr_reader :id

      ##
      # Pointer to the `PickleStep` (if derived from a `PickleStep`)

      attr_reader :pickle_step_id

      ##
      # Pointer to all the matching `StepDefinition`s (if derived from a `PickleStep`)

      attr_reader :step_definition_ids

      ##
      # A list of list of StepMatchArgument (if derived from a `PickleStep`).
      #  Each element represents a matching step definition. A size of 0 means `UNDEFINED`,
      #  and a size of 2+ means `AMBIGUOUS`

      attr_reader :step_match_arguments_lists

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          hook_id: hash[:hookId],
          id: hash[:id],
          pickle_step_id: hash[:pickleStepId],
          step_definition_ids: hash[:stepDefinitionIds],
          step_match_arguments_lists: hash[:stepMatchArgumentsLists],
        )
      end

      def initialize(
        hook_id: nil,
        id: '',
        pickle_step_id: nil,
        step_definition_ids: nil,
        step_match_arguments_lists: nil
      )
        @hook_id = hook_id
        @id = id
        @pickle_step_id = pickle_step_id
        @step_definition_ids = step_definition_ids
        @step_match_arguments_lists = step_match_arguments_lists
      end

      def to_camel_symbol_hash
        {
          hookId: hook_id,
          id: id,
          pickleStepId: pickle_step_id,
          stepDefinitionIds: step_definition_ids,
          stepMatchArgumentsLists: step_match_arguments_lists,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestCaseFinished message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class TestCaseFinished

      attr_reader :test_case_started_id

      attr_reader :timestamp

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          test_case_started_id: hash[:testCaseStartedId],
          timestamp: Timestamp.from_camel_symbol_hash(hash[:timestamp]),
        )
      end

      def initialize(
        test_case_started_id: '',
        timestamp: Timestamp.new
      )
        @test_case_started_id = test_case_started_id
        @timestamp = timestamp
      end

      def to_camel_symbol_hash
        {
          testCaseStartedId: test_case_started_id,
          timestamp: timestamp ? timestamp.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestCaseStarted message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class TestCaseStarted

      ##
      # *
      #  The first attempt should have value 0, and for each retry the value
      #  should increase by 1.

      attr_reader :attempt

      ##
      # *
      #  Because a `TestCase` can be run multiple times (in case of a retry),
      #  we use this field to group messages relating to the same attempt.

      attr_reader :id

      attr_reader :test_case_id

      attr_reader :timestamp

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          attempt: hash[:attempt],
          id: hash[:id],
          test_case_id: hash[:testCaseId],
          timestamp: Timestamp.from_camel_symbol_hash(hash[:timestamp]),
        )
      end

      def initialize(
        attempt: 0,
        id: '',
        test_case_id: '',
        timestamp: Timestamp.new
      )
        @attempt = attempt
        @id = id
        @test_case_id = test_case_id
        @timestamp = timestamp
      end

      def to_camel_symbol_hash
        {
          attempt: attempt,
          id: id,
          testCaseId: test_case_id,
          timestamp: timestamp ? timestamp.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestRunFinished message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class TestRunFinished

      ##
      # Error message. Can be a stack trace from a failed `BeforeAll` or `AfterAll`.
      #  If there are undefined parameter types, the message is simply
      #  "The following parameter type(s() are not defined: xxx, yyy".
      #  The independent `UndefinedParameterType` messages can be used to generate
      #  snippets for those parameter types.

      attr_reader :message

      ##
      # success = StrictModeEnabled ? (failed_count == 0 && ambiguous_count == 0 && undefined_count == 0 && pending_count == 0) : (failed_count == 0 && ambiguous_count == 0)

      attr_reader :success

      ##
      # Timestamp when the TestRun is finished

      attr_reader :timestamp

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          message: hash[:message],
          success: hash[:success],
          timestamp: Timestamp.from_camel_symbol_hash(hash[:timestamp]),
        )
      end

      def initialize(
        message: nil,
        success: false,
        timestamp: Timestamp.new
      )
        @message = message
        @success = success
        @timestamp = timestamp
      end

      def to_camel_symbol_hash
        {
          message: message,
          success: success,
          timestamp: timestamp ? timestamp.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestRunStarted message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class TestRunStarted

      attr_reader :timestamp

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          timestamp: Timestamp.from_camel_symbol_hash(hash[:timestamp]),
        )
      end

      def initialize(
        timestamp: Timestamp.new
      )
        @timestamp = timestamp
      end

      def to_camel_symbol_hash
        {
          timestamp: timestamp ? timestamp.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestStepFinished message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class TestStepFinished

      attr_reader :test_case_started_id

      attr_reader :test_step_id

      attr_reader :test_step_result

      attr_reader :timestamp

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          test_case_started_id: hash[:testCaseStartedId],
          test_step_id: hash[:testStepId],
          test_step_result: TestStepResult.from_camel_symbol_hash(hash[:testStepResult]),
          timestamp: Timestamp.from_camel_symbol_hash(hash[:timestamp]),
        )
      end

      def initialize(
        test_case_started_id: '',
        test_step_id: '',
        test_step_result: TestStepResult.new,
        timestamp: Timestamp.new
      )
        @test_case_started_id = test_case_started_id
        @test_step_id = test_step_id
        @test_step_result = test_step_result
        @timestamp = timestamp
      end

      def to_camel_symbol_hash
        {
          testCaseStartedId: test_case_started_id,
          testStepId: test_step_id,
          testStepResult: test_step_result ? test_step_result.to_camel_symbol_hash : nil,
          timestamp: timestamp ? timestamp.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestStepResult message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class TestStepResult

      attr_reader :duration

      attr_reader :message

      attr_reader :status

      attr_reader :will_be_retried

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          duration: Duration.from_camel_symbol_hash(hash[:duration]),
          message: hash[:message],
          status: hash[:status],
          will_be_retried: hash[:willBeRetried],
        )
      end

      def initialize(
        duration: Duration.new,
        message: nil,
        status: TestStepResultStatus::UNKNOWN,
        will_be_retried: false
      )
        @duration = duration
        @message = message
        @status = status
        @will_be_retried = will_be_retried
      end

      def to_camel_symbol_hash
        {
          duration: duration ? duration.to_camel_symbol_hash : nil,
          message: message,
          status: status,
          willBeRetried: will_be_retried,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the TestStepStarted message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class TestStepStarted

      attr_reader :test_case_started_id

      attr_reader :test_step_id

      attr_reader :timestamp

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          test_case_started_id: hash[:testCaseStartedId],
          test_step_id: hash[:testStepId],
          timestamp: Timestamp.from_camel_symbol_hash(hash[:timestamp]),
        )
      end

      def initialize(
        test_case_started_id: '',
        test_step_id: '',
        timestamp: Timestamp.new
      )
        @test_case_started_id = test_case_started_id
        @test_step_id = test_step_id
        @timestamp = timestamp
      end

      def to_camel_symbol_hash
        {
          testCaseStartedId: test_case_started_id,
          testStepId: test_step_id,
          timestamp: timestamp ? timestamp.to_camel_symbol_hash : nil,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the Timestamp message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class Timestamp

      ##
      # Represents seconds of UTC time since Unix epoch
      #  1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
      #  9999-12-31T23:59:59Z inclusive.

      attr_reader :seconds

      ##
      # Non-negative fractions of a second at nanosecond resolution. Negative
      #  second values with fractions must still have non-negative nanos values
      #  that count forward in time. Must be from 0 to 999,999,999
      #  inclusive.

      attr_reader :nanos

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          seconds: hash[:seconds],
          nanos: hash[:nanos],
        )
      end

      def initialize(
        seconds: 0,
        nanos: 0
      )
        @seconds = seconds
        @nanos = nanos
      end

      def to_camel_symbol_hash
        {
          seconds: seconds,
          nanos: nanos,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end


    ##
    # Represents the UndefinedParameterType message in Cucumber's {message protocol}[https://github.com/cucumber/common/tree/main/messages#readme].
    #
    
    #

    class UndefinedParameterType

      attr_reader :expression

      attr_reader :name

      def self.from_json(json)
        from_camel_symbol_hash(JSON.parse(json, {symbolize_names: true}))
      end

      def self.from_camel_symbol_hash(hash)
        return nil if hash.nil?
        self.new(
          expression: hash[:expression],
          name: hash[:name],
        )
      end

      def initialize(
        expression: '',
        name: ''
      )
        @expression = expression
        @name = name
      end

      def to_camel_symbol_hash
        {
          expression: expression,
          name: name,
        }.delete_if {|k,v| v.nil?}
      end

      def to_json
        to_camel_symbol_hash.to_json
      end

    end

  end
end

class Cucumber::Messages::AttachmentContentEncoding
  IDENTITY = 'IDENTITY'
  BASE64 = 'BASE64'
end

class Cucumber::Messages::SourceMediaType
  TEXT_X_CUCUMBER_GHERKIN_PLAIN = 'text/x.cucumber.gherkin+plain'
  TEXT_X_CUCUMBER_GHERKIN_MARKDOWN = 'text/x.cucumber.gherkin+markdown'
end

class Cucumber::Messages::StepDefinitionPatternType
  CUCUMBER_EXPRESSION = 'CUCUMBER_EXPRESSION'
  REGULAR_EXPRESSION = 'REGULAR_EXPRESSION'
end

class Cucumber::Messages::TestStepResultStatus
  UNKNOWN = 'UNKNOWN'
  PASSED = 'PASSED'
  SKIPPED = 'SKIPPED'
  PENDING = 'PENDING'
  UNDEFINED = 'UNDEFINED'
  AMBIGUOUS = 'AMBIGUOUS'
  FAILED = 'FAILED'
end
